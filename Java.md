# Java собеседование

## ООП ##

1) **Какие особенности есть у Java?**
    1. ООП концепты:
        1. Объектная ориентированность
        2. наследование
        3. инкапсуляция
        4. полиморфизм
        5. абстракция
    2. Кроссплатформенность: программа на Java может быть запущена на любой платформе без изменений (JVM)
    3. Высокая производительность: JIT(Just In Time compiler) позволяет высокую производительность. JIT конвертирует
       байт-код в машинный код и потом JVM стартует выполнение.
    4. Мультипоточность: поток выполнения, извстеный как __Thread__. JVM создает thread, который называется _main
       thread_. Можно создать несколько потоков наследованием от класса __Thread__ или реализуя интерфейс __Runnable__.
2) **Что такое наследование?** \
   Под наследованием подразумевается, что один класс наследует другой класс (extends).
   Существующий класс известен как superclass, а создаваемый — subclass. Также еще говорят parent и child.

```
public class Animal {
   private int age;
   }

public class Dog extends Animal {

}
```

3) **Что такое инкапсуляция?** \
   Инкапсуляция — это сокрытие реализации при помощи модификаторов доступа, при помощи геттеров и сеттеров. Это делается
   для того, чтобы закрыть доступ для внешнего использования в тех местах, где разработчики считают нужным.

   Доступный пример из жизни — это автомобиль. У нас нет прямого доступа к работе двигателя. Для нас работа заключается
   в том, чтобы вставить ключ в зажигание и включить двигатель. А какие уже процессы будут происходить под капотом — не
   наше дело.

   Даже более того, наше вмешательство в эту деятельность может привести к непредсказуемой ситуации, из-за которой можно
   и машину сломать, и себе навредить. Ровно то же самое происходит и в программировании.
4) **Что такое полиморфизм?** \
   Полиморфизм — это способность программы идентично использовать объекты с одинаковым интерфейсом без информации о
   конкретном типе этого объекта. Как говорится, один интерфейс — множество реализаций.

   При помощи полиморфизма можно объединять и использовать разные типы объектов по их общему поведению.

   Например, есть у нас класс Animal, у которого есть два наследника — Dog и Cat. У общего класса Animal есть общее
   поведение для всех — издавать звук. В случае, когда нужно собрать воедино всех наследников класса Animal и выполнить
   метод "издавать звук", используем возможности полиморфизма. Вот как будет это выглядеть:
    ```
   List<Animal> animals = Arrays.asList(new Cat(), new Dog(), new Cat());
    animals.forEach(animal -> animal.makeSound());

## Java Syntax ##

5) **Что такое конструктор в Java?** \
   Следующие характеристики являются валидными:
    1) Когда новый объект создается, программа использует для этого соответствующий конструктор.
    2) Конструктор похож на метод. Его особенность заключается в том, что нет возвращающего элемента (в том числе и
       void), а его имя совпадает с именем класса.
    3) Если не пишется никакого конструктора явно, пустой конструктор будет создан автоматически.
    4) Конструктор может быть переопределен.
    5) Если был создан конструктор с параметрами, а нужен еще и без параметров, его нужно писать отдельно, так как он не
       создается автоматически.
6) **Какие 2 класса не наследуются от Object?** \
   Таких классов нет, все классы прямо или через предков наследуются от класса Object.
7) **Что такое Local Variable?** \
   Local variable — это переменная, которая определена внутри метода и существует вплоть до того момента, пока
   выполняется этот метод. Как только выполнение закончится, локальная переменная перестанет существовать.
   Вот программа, которая использует локальную переменную helloMessage в методе main():
    ```
   public static void main(String[] args) {
     String helloMessage;
     helloMessage = "Hello, World!";
     System.out.println(helloMessage);
   }
8) **Что такое Instance Variable?** \
   Instance Variable — переменная, которая определена внутри класса, и она существует вплоть до того момента, пока
   существует объект.
   Пример — класс Bee, в котором есть две переменные nectarCapacity и maxNectarCapacity:
    ```
    public class Bee {

      /**
      * Current nectar capacity
      */
      private double nectarCapacity;

      /**
       * Maximal nectar that can take bee.
       */
      private double maxNectarCapacity = 20.0;

       ...
    }

9) **Что такое модификаторы доступа?** \
   Модификаторы доступа — это инструмент, при помощи которого можно настроить доступ к классам, методам и переменным.
   Бывают следующие модификаторы, упорядоченные в порядке повышения доступа:
    1) ```private``` — используется для методов, полей и конструкторов. Уровень доступа — только класс, внутри которого
       он объявлен.
    2) ```package-private(default)``` — может использоваться для классов. Доступ только в конкретном пакете (package), в
       котором объявлен класс, метод, переменная, конструктор.
    3) ```protected``` — такой же доступ, как и ```package-private``` + для тех классов, которые наследуются от класса с
       модификатором ```protected```.
    4) ```public``` — используется и для классов. Полноценный доступ во всем приложении.
10) **Что такое переопределение (overriding) методов?** \
    Переопределение методов происходит, когда child хочет изменить поведение parent класса. Если нужно, чтоб
    выполнилось-таки то, что есть в методе parent, можно использовать в child конструкцию вида super.methodName(), что
    выполнит работу parent метода, а уже потом добавить логику.
    Требования, которые нужно соблюдать:
    1) сигнатура метода должна быть такая же;
    2) возвращаемое значение должно быть таким же.
11) **Что такое сигнатура метода?** \
    Сигнатура метода — это набор из названия метода и аргументов, какие принимает метод.

    Сигнатура метода является уникальным идентификатором для метода при перегрузке методов.
12) **Что такое перегрузка методов?** \
    Перегрузка методов — это свойство полиморфизма, в котором при помощи изменения сигнатуры метода можно создать разные
    методы для одних действий:
    1) одно и то же имя метода;
    2) разные аргументы;
    3) может быть разный возвращаемый тип

    Например, один и тот же ```add()``` из ```ArrayList``` может быть перегружен следующим образом и будет выполнять
    добавление разным способом, в зависимости от входящих аргументов:
    1) ```add(Object o)``` — просто добавляет объект;
    2) ```add(int index, Object o)``` — добавляет объект в определенный индекс;
    3) ```add(Collection<Object> c)``` — добавляет список объектов;
    4) ```add(int index, Collection<Object> c)``` — добавляет список объектов, начиная с определенного индекса.
13) **Что такое Interface?**  \
    Множественное наследование не реализовано в джаве, поэтому чтобы преодолеть эту проблему, были добавлены интерфейсы
    в том виде, в котором мы их знаем ;)

    Долгое время у интерфейсов были только методы без их реализации. В рамках этого ответа поговорим именно о них.
    Например:
    ```
    public interface Animal {
       void makeSound();
       void eat();
       void sleep();
    }
    ```
    Из этого вытекают некоторые нюансы:
    1) все методы в интерфейсе — публичные и абстрактные;
    2) все переменные — public static final;
    3) классы не наследуют их (extends), реализовывают (implements). Причем реализовывать можно сколь угодно много
       интерфейсов.
    4) классы, которые реализуют интерфейс, должны предоставить реализацию всех методов, которые есть в интерфейсе.

    ```
    public class Cat implements Animal {
       public void makeSound() {
           // реализация метода
       }

       public void eat() {
          // реализация
       }

       public void sleep() {
          // реализация
       }   
    }
    ```
14) **Что такое default method в Interface?** \
    Эти методы добавили, чтобы все сделать "и вашим, и нашим".

    О чем это я? Да о том, что с одной стороны нужно было добавить новую функциональность: лямбды, Stream API, с другой
    стороны, нужно было оставить то, чем славится джава — обратную совместимость. Для этого нужно было ввести уже
    готовые решения в интерфейсы. Так к нам и пришли дефолтные методы.

    То есть, дефолтный метод — это реализованный метод в интерфейсе, у которого есть ключевое слово ```default```.

    Например, всем известный метод ```stream()``` в интерфейсе ```Collection```. Проверьте, этот интерфейс вовсе не так
    прост как кажется.

    Или также не менее известный метод ```forEach()``` из интерфейса ```Iterable```. Его также не было до тех пор, пока
    не добавили дефолтные методы.
15) **А как тогда наследовать два одинаковых дефолтных метода?** \
    Исходя из предыдущего ответа на то, что такое дефолтный метод, можно задать другой вопрос.

    Если можно реализовать методы в интерфейсах, то теоретически можно реализовать два интерфейса с одинаковым методом,
    и как такое делать?

    Есть два разных интерфейса с одинаковым методом:
    ```
    interface A {
       default void foo() {
           System.out.println("Foo A");
       }
    }

    interface B {
       default void foo() {
           System.out.println("Foo B");
       }
    }
    ```
    И есть класс, который реализует эти два интерфейса. Чтобы не было неопределенности и скомпилировался код, нам нужно
    переопределить метод ```foo()``` в классе ```C```, причем можно просто вызвать в нем метод ```foo()``` любого из
    интерфейсов — ```A``` или ```B```. Но только как выбрать специфический метод интерфейса ```А``` или ```В```?
    Для этого есть конструкция такого вида: ```A.super.foo()```:
    ```
    public class C implements A, B {
       @Override
       public void foo() {
           A.super.foo();
       }
    }
    ```
    или:
    ```
    public class C implements A, B {
       @Override
       public void foo() {
           B.super.foo();
       }
    }
    ```
    Таким образом, метод ```foo()``` класса ```C``` будет использовать либо дефолтный метод ```foo()``` из
    интерфейса ```A```, либо метод ```foo()``` из интерфейса ```B```.

16) **Что такое абстрактные методы и классы?** \
    В джава есть зарезервированное слово ```abstract```, которое используется для обозначения абстрактных классов и
    методов.
    Для начала — определения.

    Абстрактным методом называется метод, который создан без реализации с ключевым словом ```abstract``` в абстрактном
    классе. То есть, это метод как в интерфейсе, только с добавкой ключевого слова, например:
    ```public abstract void foo();```
    Абстрактный класс:
    ```public abstract class A { }```
    У абстрактного класса есть несколько особенностей:
    1) на его основе нельзя создать объект;
    2) он может иметь абстрактные методы;
    3) он может и не иметь абстрактные методы.
       Абстрактные классы нужны для обобщения какой-то абстракции (сорян за тавтологию), которой в реальной жизни нет,
       но она содержит множество общих поведений и состояний (то есть, методов и переменных).

17) **Какая разница между String, String Builder и String Buffer?** \
    Значения ```String``` хранятся в пуле стрингов (constant string pool). Как только будет создана строка, она появится
    в этом пуле. И удалить ее будет нельзя. \
    *String Buffer*:
    1) значения String хранятся в стеке(Stack). Если значение изменено, значит новое значение будет заменено на старое;
    2) String Buffer синхронизирован, и поэтому он потокобезопасный;
    3) из-за потокобезопасности скорость работы оставляет желать лучшего.

    *StringBuilder*

    Точно такой же, как и ```StringBuffer```, только он не потокобезопасный. Поэтому скорость его явно выше, чем
    в ```StringBuffer```.
18) **Какая разница между абстрактным классрм и интерфейсом?** \
    Абстрактный класс:
    1) абстрактные классы имеют дефолтный конструктор; он вызывается каждый раз, когда создается потомок этого
       абстрактного класса;
    2) cодержит как абстрактные методы, так и не абстрактные. По большому счету может и не содержать абстрактных
       методов, но все равно быть абстрактным классом;
    3) класс, который наследуется от абстрактного, должен реализовать только абстрактные методы;
    4) абстрактный класс может содержать Instance Variable(смотри вопрос №5).
       **Интерфейс**: \
       a) не имеет никакого конструктора и не может быть инициализирован; \
       b) только абстрактные методы должны быть добавлены (не считая default methods); \
       c) классы, реализующие интерфейс, должны реализовать все методы (не считая default methods); \
       d) интерфейсы могут содержать только константы
19) **Почему доступ по элементу в массиве происходит за О(1)?** \
    У машины есть начало выделенной памяти, количество элементов и размер одной ячейки.
20) **Почему получается О(1) в доступе к объектам в ArrayList?** \
    В коллекции хранятся не объекты, а ссылки на эти объекты. А у всех ссылок размер один и тот же, и он также известен.
    Поэтому подсчет места считается также, как и в прошлом вопросе.
21) **Автоупаковка и Автораспаковка** \
    Автоупаковка - процесс автоматического преобразования из примитивного типа в соответствующий класс обертку.
    Автораспаковка - делат ровно обратное к автоупаковке - преобразует класс обертку в примитив. А вот если окажется
    значение обертки ```null```, то при распаковке будет выброшено исключение ```NullPointerException```. \
    Автоупаковка происходит в двух случаях: когда присваивают примитиву ссылку на класс обертку и когда передают
    примитив в аргумент метода, который ожидает обертку. \
    Автораспаковка происходит в 3 случаях: когда присваиваем классу обертке примитивную переменную, в случаях с
    арифметическими операциями, когда передают в обертку в метод, который принимает соответсвующий примитив.
22) **Что такое ключевое слово final и где его использовать?** \
    Как и где использовать final в Java:
    1) чтобы определить некоторые константы уровня класса
    2) Создавать final переменные для объектов, когда вы не хотите, чтобы они были изменены.
    3) Если не нужно, чтобы класс был расширен, отметить его как окончательный
    4) Если нужно создать immutable класс, нужно сделать его финальным
    5) Если нужно, чтобы реализация метода не менялась в наследниках, обозначить метод как final

23) **Что такое mutable immutable?** \
    mutable - объекты, чьи состояния и переменные можно изменить после создания. (просто наличие сеттера) \
    immutable - объекты, состояния и переменные которых нельзя изменить после создания объекта. (отсутствие сеттера)
24) **Как написать immutable класс?**
    1) сделать класс финальным
    2) сделать все поля приватными и создать только геттеры к ним
    3) сделать все mutable поля final, чтобы установить значение можно было только 1 раз
    4) инициализировать все поля через конструктор, выполняя глубокое копирование
    5) клонировать объекты mutable переменных в геттерах, чтобы возвращать только копии значений, а не ссылки на
       актуальные объекты

    
