# Java собеседование

## ООП ##

1) **Какие особенности есть у Java?** 
    1. ООП концепты:
        1. Объектная ориентированность
        2. наследование
        3. инкапсуляция
        4. полиморфизм
        5. абстракция
    2. Кроссплатформенность: программа на Java может быть запущена на любой платформе без изменений (JVM)
    3. Высокая производительность: JIT(Just In Time compiler) позволяет высокую производительность. JIT конвертирует
       байт-код в машинный код и потом JVM стартует выполнение.
    4. Мультипоточность: поток выполнения, извстеный как __Thread__. JVM создает thread, который называется _main
       thread_. Можно создать несколько потоков наследованием от класса __Thread__ или реализуя интерфейс __Runnable__.
2) **Что такое наследование?** \
   Под наследованием подразумевается, что один класс наследует другой класс (extends).
   Существующий класс известен как superclass, а создаваемый — subclass. Также еще говорят parent и child.

```
public class Animal {
   private int age;
   }

public class Dog extends Animal {

}
```

3) **Что такое инкапсуляция?** \
   Инкапсуляция — это сокрытие реализации при помощи модификаторов доступа, при помощи геттеров и сеттеров. Это делается
   для того, чтобы закрыть доступ для внешнего использования в тех местах, где разработчики считают нужным.

   Доступный пример из жизни — это автомобиль. У нас нет прямого доступа к работе двигателя. Для нас работа заключается
   в том, чтобы вставить ключ в зажигание и включить двигатель. А какие уже процессы будут происходить под капотом — не
   наше дело.

   Даже более того, наше вмешательство в эту деятельность может привести к непредсказуемой ситуации, из-за которой можно
   и машину сломать, и себе навредить. Ровно то же самое происходит и в программировании.
4) **Что такое полиморфизм?** \
   Полиморфизм — это способность программы идентично использовать объекты с одинаковым интерфейсом без информации о
   конкретном типе этого объекта. Как говорится, один интерфейс — множество реализаций.

   При помощи полиморфизма можно объединять и использовать разные типы объектов по их общему поведению.

   Например, есть у нас класс Animal, у которого есть два наследника — Dog и Cat. У общего класса Animal есть общее
   поведение для всех — издавать звук. В случае, когда нужно собрать воедино всех наследников класса Animal и выполнить
   метод "издавать звук", используем возможности полиморфизма. Вот как будет это выглядеть:
    ```
   List<Animal> animals = Arrays.asList(new Cat(), new Dog(), new Cat());
    animals.forEach(animal -> animal.makeSound());

## Java Syntax ##

5) **Что такое конструктор в Java?** \
   Следующие характеристики являются валидными:
    1) Когда новый объект создается, программа использует для этого соответствующий конструктор.
    2) Конструктор похож на метод. Его особенность заключается в том, что нет возвращающего элемента (в том числе и
       void), а его имя совпадает с именем класса.
    3) Если не пишется никакого конструктора явно, пустой конструктор будет создан автоматически.
    4) Конструктор может быть переопределен.
    5) Если был создан конструктор с параметрами, а нужен еще и без параметров, его нужно писать отдельно, так как он не
       создается автоматически.
6) **Какие 2 класса не наследуются от Object?** \
   Таких классов нет, все классы прямо или через предков наследуются от класса Object.
7) **Что такое Local Variable?** \
   Local variable — это переменная, которая определена внутри метода и существует вплоть до того момента, пока
   выполняется этот метод. Как только выполнение закончится, локальная переменная перестанет существовать.
   Вот программа, которая использует локальную переменную helloMessage в методе main():
    ```
   public static void main(String[] args) {
     String helloMessage;
     helloMessage = "Hello, World!";
     System.out.println(helloMessage);
   }
8) **Что такое Instance Variable?** \
   Instance Variable — переменная, которая определена внутри класса, и она существует вплоть до того момента, пока
   существует объект.
   Пример — класс Bee, в котором есть две переменные nectarCapacity и maxNectarCapacity:
    ```
    public class Bee {

      /**
      * Current nectar capacity
      */
      private double nectarCapacity;

      /**
       * Maximal nectar that can take bee.
       */
      private double maxNectarCapacity = 20.0;

       ...
    }

9) **Что такое модификаторы доступа?** \
   Модификаторы доступа — это инструмент, при помощи которого можно настроить доступ к классам, методам и переменным.
   Бывают следующие модификаторы, упорядоченные в порядке повышения доступа:
    1) ```private``` — используется для методов, полей и конструкторов. Уровень доступа — только класс, внутри которого
       он объявлен.
    2) ```package-private(default)``` — может использоваться для классов. Доступ только в конкретном пакете (package), в
       котором объявлен класс, метод, переменная, конструктор.
    3) ```protected``` — такой же доступ, как и ```package-private``` + для тех классов, которые наследуются от класса с
       модификатором ```protected```.
    4) ```public``` — используется и для классов. Полноценный доступ во всем приложении.
       ![Снимок экрана 2024-04-19 в 04.46.27.png](..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fxz%2Flfy09pds5y794pbnvly7sz_w0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_nh3bat%2F%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-04-19%20%D0%B2%2004.46.27.png)
10) **Что такое переопределение (overriding) методов?** \
    Переопределение методов происходит, когда child хочет изменить поведение parent класса. Если нужно, чтоб
    выполнилось-таки то, что есть в методе parent, можно использовать в child конструкцию вида super.methodName(), что
    выполнит работу parent метода, а уже потом добавить логику.
    Требования, которые нужно соблюдать:
    1) сигнатура метода должна быть такая же;
    2) возвращаемое значение должно быть таким же.
11) **Что такое сигнатура метода?** \
    Сигнатура метода — это набор из названия метода и аргументов, какие принимает метод.

    Сигнатура метода является уникальным идентификатором для метода при перегрузке методов.
12) **Что такое перегрузка методов?** \
    Перегрузка методов — это свойство полиморфизма, в котором при помощи изменения сигнатуры метода можно создать разные
    методы для одних действий:
    1) одно и то же имя метода;
    2) разные аргументы;
    3) может быть разный возвращаемый тип

    Например, один и тот же ```add()``` из ```ArrayList``` может быть перегружен следующим образом и будет выполнять
    добавление разным способом, в зависимости от входящих аргументов:
    1) ```add(Object o)``` — просто добавляет объект;
    2) ```add(int index, Object o)``` — добавляет объект в определенный индекс;
    3) ```add(Collection<Object> c)``` — добавляет список объектов;
    4) ```add(int index, Collection<Object> c)``` — добавляет список объектов, начиная с определенного индекса.
13) **Что такое Interface?**  \
    Множественное наследование не реализовано в джаве, поэтому чтобы преодолеть эту проблему, были добавлены интерфейсы
    в том виде, в котором мы их знаем ;)

    Долгое время у интерфейсов были только методы без их реализации. В рамках этого ответа поговорим именно о них.
    Например:
    ```
    public interface Animal {
       void makeSound();
       void eat();
       void sleep();
    }
    ```
    Из этого вытекают некоторые нюансы:
    1) все методы в интерфейсе — публичные и абстрактные;
    2) все переменные — public static final;
    3) классы не наследуют их (extends), реализовывают (implements). Причем реализовывать можно сколь угодно много
       интерфейсов.
    4) классы, которые реализуют интерфейс, должны предоставить реализацию всех методов, которые есть в интерфейсе.

    ```
    public class Cat implements Animal {
       public void makeSound() {
           // реализация метода
       }

       public void eat() {
          // реализация
       }

       public void sleep() {
          // реализация
       }   
    }
    ```
14) **Что такое default method в Interface?** \
    Эти методы добавили, чтобы все сделать "и вашим, и нашим".

    О чем это я? Да о том, что с одной стороны нужно было добавить новую функциональность: лямбды, Stream API, с другой
    стороны, нужно было оставить то, чем славится джава — обратную совместимость. Для этого нужно было ввести уже
    готовые решения в интерфейсы. Так к нам и пришли дефолтные методы.

    То есть, дефолтный метод — это реализованный метод в интерфейсе, у которого есть ключевое слово ```default```.

    Например, всем известный метод ```stream()``` в интерфейсе ```Collection```. Проверьте, этот интерфейс вовсе не так
    прост как кажется.

    Или также не менее известный метод ```forEach()``` из интерфейса ```Iterable```. Его также не было до тех пор, пока
    не добавили дефолтные методы.
15) **А как тогда наследовать два одинаковых дефолтных метода?** \
    Исходя из предыдущего ответа на то, что такое дефолтный метод, можно задать другой вопрос.

    Если можно реализовать методы в интерфейсах, то теоретически можно реализовать два интерфейса с одинаковым методом,
    и как такое делать?

    Есть два разных интерфейса с одинаковым методом:
    ```
    interface A {
       default void foo() {
           System.out.println("Foo A");
       }
    }

    interface B {
       default void foo() {
           System.out.println("Foo B");
       }
    }
    ```
    И есть класс, который реализует эти два интерфейса. Чтобы не было неопределенности и скомпилировался код, нам нужно переопределить метод ```foo()``` в классе ```C```, причем можно просто вызвать в нем метод ```foo()``` любого из интерфейсов — ```A``` или ```B```. Но только как выбрать специфический метод интерфейса ```А``` или ```В```?
    Для этого есть конструкция такого вида: ```A.super.foo()```:
    ```
    public class C implements A, B {
       @Override
       public void foo() {
           A.super.foo();
       }
    }
    ```
    или:
    ```
    public class C implements A, B {
       @Override
       public void foo() {
           B.super.foo();
       }
    }
    ```
    Таким образом, метод ```foo()``` класса ```C``` будет использовать либо дефолтный метод ```foo()``` из интерфейса ```A```, либо метод ```foo()``` из интерфейса ```B```.

